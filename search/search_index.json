{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"awl-python","text":"<p>Python implementation of the Abstract Workflow Language (AWL / AWL-LD)</p>"},{"location":"#install","title":"Install","text":"<p><code>pip install awl</code></p>"},{"location":"#usage","title":"Usage","text":"<pre><code>from awl import AstSerialization\n\nast_serialization = AstSerialization()\n\n# python source code example\nsource = \"\"\"if a == 1:\nb = 1\nelse:\nb = 'test'\"\"\"\n\n# generate ast document\nast_dict = ast_serialization.parse(source)\nprint(ast_serialization.dumps())\n\n# regenerate source code\nsrc_code = ast_serialization.unparse(ast_dict)\nassert src_code == source\n\n# manipulate ast_dict: set b = 2\nast_dict[\"body\"][0][\"body\"][0][\"value\"][\"value\"] = 2\nsrc_code = ast_serialization.unparse(ast_dict)\n\nassert src_code == \"\"\"if a == 1:\nb = 2\nelse:\nb = 'test'\"\"\"\n\n# export as json-ld\njsonld_doc = ast_serialization.to_jsonld()\n\n# import into a graph\nfrom rdflib import Graph\ng = Graph()\ng.parse(data=jsonld_doc, format=\"json-ld\")\n\n# dump graph as turtle\nprint(g.serialize(format=\"turtle\"))\n\n# query for all possible values of b\nqres = g.query(\n    \"\"\"\n    PREFIX awl: &lt;https://w3id.org/awl/schema/&gt;\n    PREFIX ex: &lt;https://example.org/&gt;\n    SELECT ?v\n    WHERE {\n        ?a a awl:Assign .\n        ?a awl:HasTarget ex:b .\n        ?a awl:HasValue ?v .\n    }\n    \"\"\"\n)\n\npossible_values = [row[0].toPython() for row in qres]\nassert possible_values == [1, \"test\"]\n</code></pre>"},{"location":"awl/","title":"Awl","text":"<p>Classes</p>"},{"location":"awl/#astserialization","title":"AstSerialization","text":"Source code in <code>src/awl/core.py</code> <pre><code>class AstSerialization:\n    def __init__(self, annotate: bool = False, backparsable: bool = False) -&gt; None:\n        \"\"\"\n        Initializes AstSerialization with parser options.\n\n        Parameters\n        ----------\n        annotate : bool, default False\n            If ``True``, annotates the AST tree\n        backparsable : bool, default False\n            If ``True``, AST tree is unparsable via self.unparse\n            If ``False``, Annotations deletes that are required for unparsing,\n             resulting in a neat tree\n        \"\"\"\n        self.annotate = annotate\n        self.backparsable = backparsable\n\n    @staticmethod\n    def del_keys(d: dict, keys: list) -&gt; dict:\n        for key in keys:\n            if key in d:\n                del d[key]\n        for key, value in d.items():\n            if isinstance(value, dict):\n                AstSerialization.del_keys(value, keys)\n            elif isinstance(value, list):\n                for item in value:\n                    if isinstance(item, dict):\n                        AstSerialization.del_keys(item, keys)\n        return d\n\n    @staticmethod\n    def add_key(d: dict, k: str, v) -&gt; dict:\n        d[k] = v\n        for key, value in d.items():\n            if isinstance(value, dict):\n                AstSerialization.add_key(value, k, v)\n            elif isinstance(value, list):\n                for item in value:\n                    if isinstance(item, dict):\n                        AstSerialization.add_key(item, k, v)\n        return d\n\n    def parse(self, source: str) -&gt; dict:\n        ast_dict = ast2json(ast.parse(source))\n\n        rm_keywords = [\n            \"col_offset\",\n            \"end_col_offset\",\n            \"end_lineno\",\n            \"lineno\",\n            \"type_comment\",\n            \"n\",\n            \"s\",\n            \"kind\",\n            \"ctx\",\n        ]\n\n        ast_dict = self.del_keys(ast_dict, rm_keywords)  # remove annotations\n        self.ast_dict = ast_dict\n\n        if self.annotate:\n            self.annotate_ast()\n\n        return ast_dict\n\n    def unparse(self, ast_dict: dict = None) -&gt; str:\n        ast_dict = self.add_key(ast_dict, \"lineno\", 0)  # needed to unparse\n        ast_tree = json2ast(ast_dict)\n        source = ast.unparse(ast_tree)\n        return source\n\n    def dumps(self, format=\"yaml\") -&gt; str:\n        res = \"\"\n        if format == \"json\":\n            res = json.dumps(self.ast_dict, indent=4)\n        elif format == \"yaml\":\n            res = yaml.dump(self.ast_dict, indent=4)\n        return res\n\n    def annotate_ast(self) -&gt; None:\n        \"\"\"Validate the root node and start annotation walk.\n        Raises\n        ------\n        ASTNotAModule\n            If the parsed tree does **not** start with an ``ast.Module`` node.\n        \"\"\"\n        # todo add further veryfication\n        if self.ast_dict.get(\"_type\") != \"Module\":\n            raise ASTNotAModule(\"root node is not a Module\")\n        self._walk_json_ast(self.ast_dict, path=None)\n\n    def _walk_json_ast(self, node: list | dict | object, path: list) -&gt; None:\n        \"\"\"Depth\u2011first traversal of *node* while keeping track of *path*.\n\n        Parameters\n        ----------\n        node\n            Current AST sub\u2011node (``dict``, ``list`` or scalar).\n        path\n            Accumulated list of keys / indices leading from the root to *node*.\n        \"\"\"\n\n        if path is None:\n            path = []\n        # ------------------------------------------------------------------ #\n        # 1.Recursive walk\n        # ------------------------------------------------------------------ #\n        elif isinstance(node, list):\n            # print(f\"Path: {path}\")\n            for index, item in enumerate(node):\n                self._walk_json_ast(item, path + [index])\n\n        if isinstance(node, dict):\n            # print(f\"Path: {path}\")\n            for key, value in node.items():\n                self._walk_json_ast(value, path + [key])\n\n        # Primitive leaf \u2013 nothing to do\n        else:\n            # print(f\"Path: {path} -&gt; Value: {node}\")\n            pass\n\n        # ------------------------------------------------------------------ #\n        # 2.Collapse handles the replacement logic to from leaf to \"stem\"\n        # ------------------------------------------------------------------ #\n\n        # This checks for the class constructor syntax in AST\n        # e.g \"value\":\n        # {\"_type\": \"Call\",\"args\": [],\"func\": {\"_type\": \"Name\",\"id\": \"ClassA\"}\n        if isinstance(node, dict):\n            if (\n                node.get(\"_type\") == \"Call\"  # A Constructor is a call\n                and node.get(\"func\", {}).get(\"_type\")\n                == \"Name\"  # A Constructor is a call of type Name\n                and (\n                    fid := node.get(\"func\", {}).get(\"id\")\n                )  # fid is None if the path is missing and hence False\n                and fid[0].isupper()  # only runs if fid is truthy,\n                # wont give TypeError/IndexError\n            ):\n                ctor_node = AstSerialization._get_from_path(self.ast_dict, path)\n\n                ctor_node[\"__class_name__\"] = fid\n                # self.ast_dict[\"__class_name__\"] = fid\n                # print (fid)\n\n                for kw_node in node[\"keywords\"]:\n                    if isinstance(kw_node, dict):\n                        if kw_node.get(\"_type\") == \"keyword\":\n                            ctor_node[kw_node[\"arg\"]] = self._val(kw_node[\"value\"])\n\n                if self.backparsable is False:\n                    # slim notation\n                    ctor_node = AstSerialization.slim_notation(ctor_node)\n\n    @staticmethod\n    def _val(node: list | dict | object) -&gt; object | None:\n        \"\"\"Convert AST *value* nodes into primitives or nested constructor annotations.\n\n        Returns\n        -------\n        object | None\n            * ``int``, ``str`` \u2026 for ``Constant`` nodes;\n            * dotted ``str`` for ``Attribute`` chains;\n            * nested constructor annotations (dict) for embedded calls;\n            * ``None`` for values that are irrelevant / not serialisable.\n        \"\"\"\n\n        if isinstance(node, dict):\n            # todo currently f(a=t) and f(a=\"t\") have same annotation,\n            #  think about if this can lead to problems\n            t = node.get(\"_type\")\n            ctor = node.get(\"__class_name__\")\n            # f(a=1) :\"value\": {\"_type\": \"Constant\",\"value\": 1}\n            if t == \"Constant\":\n                return node[\"value\"]\n            # f(a=t) : \"value\": {\"_type\": \"Name\",\"id\": \"t\"}\n            if t == \"Name\":\n                return node[\"id\"]\n            # f(a = U.V) : \"value\":\n            # {\"_type\": \"Attribute\",\"attr\": \"V\",\"value\": {\"_type\": \"Name\",\"id\": \"U\"}}\n            if t == \"Attribute\":\n                return AstSerialization._attr_to_str(node)\n            if ctor:\n                return AstSerialization.slim_notation(node.copy())\n        return None\n\n    # ------------------------------------------------------------------ #\n    # Attribute -&gt; dotted string\n    # ------------------------------------------------------------------ #\n    @staticmethod\n    def _attr_to_str(node: dict) -&gt; str:\n        \"\"\"Flatten a chain of ``Attribute``/``Name`` nodes into ``\"U.V\"``.\"\"\"\n        # f(a = U.V) : \"value\":\n        # {\"_type\": \"Attribute\",\"attr\": \"V\",\"value\": {\"_type\": \"Name\",\"id\": \"U\"}}\n        parts: list[str] = []\n\n        def walk(n):\n            if n[\"_type\"] == \"Attribute\":\n                walk(n[\"value\"])\n                parts.append(n[\"attr\"])\n            elif n[\"_type\"] == \"Name\":\n                parts.append(n[\"id\"])\n\n        walk(node)\n        return \".\".join(parts)\n\n    @staticmethod\n    def _get_from_path(node: list | dict | object, path: list) -&gt; list | dict | object:\n        \"\"\"Return the sub\u2011node referenced by *path*.\"\"\"\n        for key in path:\n            node = node[key]\n        return node\n\n    @staticmethod\n    def _dump_from_path(node: list | dict | object, path: list) -&gt; str:\n        \"\"\"Pretty JSON dump of the sub\u2011node at *path* (debug helper).\"\"\"\n        node = AstSerialization._get_from_path(node, path)\n        res = json.dumps(node, indent=4)\n        return res\n\n    @staticmethod\n    def slim_notation(node: list | dict | object) -&gt; list | dict | object:\n        \"\"\"pops the unnecessary parameters of a constructor\n        and returns slim notation node\"\"\"\n        for k in (\"_type\", \"args\", \"func\", \"keywords\"):\n            node.pop(k, None)\n        return node\n\n    def to_jsonld(self) -&gt; dict:\n        res = {\"@context\": jsonld_context.awl_context[\"@context\"], **self.ast_dict}\n        return res\n</code></pre>"},{"location":"awl/#awl.AstSerialization.__init__","title":"<code>__init__(annotate=False, backparsable=False)</code>","text":"<p>Initializes AstSerialization with parser options.</p> <p>Parameters:</p> Name Type Description Default <code>annotate</code> <code>bool</code> <p>If <code>True</code>, annotates the AST tree</p> <code>False</code> <code>backparsable</code> <code>bool</code> <p>If <code>True</code>, AST tree is unparsable via self.unparse If <code>False</code>, Annotations deletes that are required for unparsing,  resulting in a neat tree</p> <code>False</code> Source code in <code>src/awl/core.py</code> <pre><code>def __init__(self, annotate: bool = False, backparsable: bool = False) -&gt; None:\n    \"\"\"\n    Initializes AstSerialization with parser options.\n\n    Parameters\n    ----------\n    annotate : bool, default False\n        If ``True``, annotates the AST tree\n    backparsable : bool, default False\n        If ``True``, AST tree is unparsable via self.unparse\n        If ``False``, Annotations deletes that are required for unparsing,\n         resulting in a neat tree\n    \"\"\"\n    self.annotate = annotate\n    self.backparsable = backparsable\n</code></pre>"},{"location":"awl/#awl.AstSerialization.annotate_ast","title":"<code>annotate_ast()</code>","text":"<p>Validate the root node and start annotation walk.</p> <p>Raises:</p> Type Description <code>ASTNotAModule</code> <p>If the parsed tree does not start with an <code>ast.Module</code> node.</p> Source code in <code>src/awl/core.py</code> <pre><code>def annotate_ast(self) -&gt; None:\n    \"\"\"Validate the root node and start annotation walk.\n    Raises\n    ------\n    ASTNotAModule\n        If the parsed tree does **not** start with an ``ast.Module`` node.\n    \"\"\"\n    # todo add further veryfication\n    if self.ast_dict.get(\"_type\") != \"Module\":\n        raise ASTNotAModule(\"root node is not a Module\")\n    self._walk_json_ast(self.ast_dict, path=None)\n</code></pre>"},{"location":"awl/#awl.AstSerialization.slim_notation","title":"<code>slim_notation(node)</code>  <code>staticmethod</code>","text":"<p>pops the unnecessary parameters of a constructor and returns slim notation node</p> Source code in <code>src/awl/core.py</code> <pre><code>@staticmethod\ndef slim_notation(node: list | dict | object) -&gt; list | dict | object:\n    \"\"\"pops the unnecessary parameters of a constructor\n    and returns slim notation node\"\"\"\n    for k in (\"_type\", \"args\", \"func\", \"keywords\"):\n        node.pop(k, None)\n    return node\n</code></pre>"},{"location":"dev/","title":"Setup","text":"<ol> <li>create a virtual environment</li> </ol> <pre><code>python -m venv .venv\n</code></pre> <ol> <li>install requirements + extras</li> </ol> <pre><code>pip install -e .[dev,testing]\n</code></pre>"},{"location":"dev/#testing","title":"Testing","text":"<ol> <li> <p>Create new test (file name test_*.py) under /tests</p> </li> <li> <p>Run pytest in the project root dir</p> </li> </ol> <pre><code>tox -e test\n</code></pre>"}]}